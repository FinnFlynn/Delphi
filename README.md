Поставленная задача –  
разработать программу-калькулятор, похожую на калькулятор Windows (в режиме «Инженерный», с некоторыми дополнениями из режима «Программист»). 

Устройства и приложения:
компьютера с ОС Windows; 
программа Delphi 12. 

Ход решения задачи: 
Общий этап 
1) установка программы, её настройка и создание проекта: 
подключаем библиотеки Math и Ce_l_lBin (Описывается в конце); 

2) создание полей ввода (Edit): 
Window_echo (Дальше по тексту We) 
отвечает за сохранение первого значения в бинарных выражениях, вывод итогового вида выражения после нажатия равно в бинарных и после действия в унарных; в случае с двумя корнями в 'Quad' выводит больший из них, в случае большинства ошибок или ограничений выводит соответствующий текст; 
Window_sign (Дальше по тексту Ws) 
отвечает за сохранение последнего значения нажатой кнопки функций, кроме '|y|', '±', 'Rdm', в случае с двумя корнями в 'Quad' выводит, что корня два; 
Window_main (Дальше по тексту Wm) 
отвечает за ввод данных и вывод ответов. Пустое значение соответствует '0'; 

3) кнопок (Button) ввода цифр (Button_"цифра" (от 0 до 9)): 
создание процедуры Add_Number (Number: String), 
проверяющей Wm на соответствие '0': если это так, то меняющей '0' на цифру равную аргументу кнопки, если нет, то приписывающей цифру следом; 
создание процедуры для каждой из кнопок, 
состоящей из вызова процедуры Add_Number ('"Цифра кнопки"'); 

4) разделения целой и дробной части ('.') (Button_dot): 
создание функции Integrt_check(Check: String): Boolean, 
проверяющей наличие '.' или ',' в аргументе, если их нет, то выводящей True, иначе False; 
создание процедуры кнопки, 
вызывающей Integrt_check(Wm), если результат True, то к Wm приписывающей '.', иначе функция игнорируется. 
создание функции Dot_check(Check: String): String, 
проверяющей символ разделения в соответствии с языком системы, в случае если система поддерживает '.' функция игнорируется, иначе '.' меняется на ','. 

5) создание кнопок изменение знака числа Button_plus_minus: 
вызывающей Dot_check() и Integrt_check(), после чего умножающей Int или Float на -1 и возвращение в Wm; 

6) очищение полей: 
всех (Button_clear_all): 
задающих значение Wm = '0', а Ws и We = '' (Пустая строка); 
ввода (Button_clear): 
задающих значение только Wm = '0'; 
удаление последнего символа (Button_backspace): 
приравнивающих Wm к его же копии без последнего символа, если длина значения равна одной цифре, то меняет её на 0; 

7) для чисел π, *(e) и случайного от 0 до 999: 
соответственно вызывающих Pi, *(Exp(1)) или Random(1000); 

*8) смены значений между полями Wm и We (Button_swap): 
объявляющей дополнительную переменную boofer: String, проверяющей есть ли число в We через try и FloatToStr(), если нет, то приравнивающей We к '0', дальше boofer = We, We = Wm, и Wm = boofer. 



Унарные функции 
1) создание процедуры для оформления We и Ws большинства унарных функций (Uno_oper(Sing: String)): 
приравнивающей We к 'символ действия' + 'Значение Wm', а Ws к '='; 

2) создание кнопок возведения в квадрат (Button_square): 
приравнивающей We к Wm + '²', Ws к '=', а Wm вызывает Sqr(); 

3) квадратного корня (Button_square_root): 
проверяющей Wm на соответствие ≥ 0, если это так, то вызывающей Uno_oper() с аргументов '√', а Wm вызывающей Sqrt(), иначе We = 'Нужно число > 0'. 

4) экспоненты (Button_exp): 
аналогично пункту 3 без проверки ≥ 0 вместо '√' и Sqrt, 'Exp' и Exp(). 

5) логарифмических унарных функций (lg; ln; log₂): 
все кнопки сначала проверяют что Wm > 0 в случае, если это не так We выводит 'Нужно число > 0', иначе: 
Десятичный (Button_lg) как пункт 4 с  'lg' и Log10(); 
Натуральные (Button_ln) как пункт 4 с  'ln' и Ln(); 
Двоичный (Button_log2) как пункт 4 с  'log₂' и Log2(); 

6) факториала (Button_factorial): 
создание функции Natural(Check: String): Boolean 
вызывающей Integrt_check() и проверяющей наличие '-', в случае получение True и отсутствии '-' возвращающей True, иначе – False; 
создание процедуры кнопки факториала   
вызывающей Natural(), если False, We  =' Нужно целое число ≥ 0'; иначе объявляющей переменные: I, F: Integer; приравнивающей We к Wm + '!'; проверяющей, если Wm = '0' или '1', то Wm =  '1', иначе F = 1, и создающей цикл с шагом в 1, начиная с 2 и до значения Wm, каждый шаг умножающей F на I и записывающей результат в F; по завершению цикла Wm = F; 

7) создание кнопок перевода в другие системы счисления: 
Десятеричную в шестнадцатеричную Hex (Button_hex): 
проверяющей целочисленность через Integrt_check(), иначе We = 'Нужно целое число'. Если число целое, записывающей в We исходное число и результат функции Hex с соответствующими подписями. 
Десятеричную в двоичную Bin (Button_bin): 
аналогично с Hex, но проверка и сообщение идёт на натуральность числа We = 'Нужно целое число ≥ 0', а вызываемая функция IntToBin (Описание в разделе собственного модуля); 
Двоичную в десятеричную Abin (Button_abin): 
проверяющей бинарность через функцию BinToInt (Описание в разделе собственного модуля), если результат -1, то We = 'Число не бинарно', иначе функция вызывается повторно и результат записывается в Wm, а в We выводится исходное число + '₂ -> ₁₀' и в Ws '='. 

8) тригонометрических функций: 
Создание пары радиокнопок, соответствующих градусам и радианам, 
к которым будут обращаться все процедуры тригонометрических кнопок, чтобы проверить формат ввода/вывода данных (градусы или радианы); 
Sin: 
вызывающей Uno_oper(), проверяющей радиокнопку, в случае градусов We = We + '°', выводящей в Wm результат функции Sin от Wm * π / 180, в случае радиан затрагивается только Wm с результатом Sin от Wm, под конец, проверяющей близость Wm к 0, если оно ближе, чем ±0.0001, то Wm = '0' (Чтобы избежать ответов в духе '-5,42101086242752E-20'); 
Cos: 
аналогично Sin, только все Sin заменяются на Cos; 
Tg: 
аналогично Sin, только все Sin заменяются на Tg, вместо округления чисел близких к 0, есть проверка входящего значение на кратность 90 и не кратность 20 (в случае радиан проверяем с переводом в градусы, чтобы отсечь ответы NAN или в духе -3,68934881474191E19 и выводить сообщение  'Tg(Wm)  — Неопределен'); 

9) обратных тригонометрических функций: 
ArcSin: 
проверяющей -1 ≤ Wm ≤ 1, если это так, то вызывающей Uno_oper(), после проверяющей радиокнопок и вызывающей Arcsin, в случае градусов преобразующей ответ как Wm / π * 180, иначе We = 'Число должно быть ≥ -1 и ≤ 1'; 
ArcCos: 
аналогично Arcsin, только все Arcsin заменяются на Arccos; 
ArcTg: 
вызывающей Uno_oper(), после проверяющей радиокнопки и выводящей ответ функции Arctg, в случае с градусами преобразующей ответ как Wm / π * 180;  

10) создание кнопки Not (Единственная унарная логическая функция): 
вызывающей Integrt_check(), если число целое вызывающей Uno_oper(), и выводящей ответ функции Not, иначе We = 'Нужно целое число'. 



Бинарные функции 
1) создание процедуры для оформления Wm, We, Ws бинарных операций 
Bin_oper(Sing: String) 
состоящей из присвоения We значение Wm, Ws аргумент Sing, а Wm '0'; 

2) создание кнопок логических операций (And, Or, Xor, ShL, ShR) и целочисленного деления и его остатка (Div, Mod): 
они все состоят из проверки на целочисленность Wm через Integrt_check() если это так, то вызывают Bin_oper() с соответствующим аргументом иначе We = 'Нужно целое число'; 

3) логарифма первого ввода, по основанию второго ввода (logᵧx) 
проверяющей Wm > 0, а также ≠ 1, если это так, вызывающей Bin_oper(), иначе We = 'Нужно число > 0 и ≠ 1'; 

4) оставшихся функций (+; -; *; /; ^; √; Max; Min; Avg;Hptn; Ctht; Quad): 
вызывающих функцию Bin_oper() с соответствующим аргументом. 



Кнопка равно (=) 
Кнопка состоит из: 
0) объявление переменных для (Quad); 
1) Dot_check() для Wm и Ws, чтобы избежать ошибок перевода в дробные числа с '.', ','; 
2) Проверки Ws на соответствие значению из групп (Or; Xor; And), (ShR; ShL), (+; -; *), (/; div; mod), (^; √; logᵧx), (Max; Min; Avg), (Ctht; Hptn; Quad); 
(Or; Xor; And): 
проверки конкретного знака; приравнивание Ws к Wm используя окно как буфер; вывод в Wm результат соответствующего действия, в We запись примера We 'действие' Ws, а в Ws символ '='; 
(ShR; ShL), (+; -; *): 
аналогично с (Or; Xor; And); 
(/; div; mod): 
аналогично (Or; Xor; And), добавляя проверку равенства Wm '0', а в случае с (div и mod) также есть проверка на целочисленность; 
(^; √; logᵧx) 
аналогично (Or; Xor; And), добавляя проверку у (√; logᵧx) Wm ≥ 0; 
(Max; Min; Avg): 
аналогично (Or; Xor; And), только в We: 'Действие (' We, ', ' Ws ')'; 
(Ctht; Hptn; Quad): 
Ctht: проверки что больше We или Wm (большее — уменьшаемое, меньшее — вычитаемое, дальше аналогично (Or; Xor; And), только действие не одноименное, а корень разности квадрата We и Wm (Wm и We); 
Hptn: аналогично (Or; Xor; And), только действие не одноименное, а корень суммы квадратов We и Wm; 
Quad: задания переменным, объявленным ранее в '=', значений, b = We, c = Wm, D = [формула дискриминанта], дальше нахождения D, если он < 0, то вывода в ответ 'Нет корней', если = 0; то нахождения одного корня, вывод его в Wm и записи в We самого примера, в случае > 0; нахождения двух корней, указанием в Ws ,что корня два и вывод в We большего, в Wm меньшего. 



Дополнительные элементы 
*0) Создание поля Window_plus_minus (Wpm) и Window_radix (Wr), с кнопки Button_redix и Button_change, первая кнопка приравнивает поле Wr к Wm, если в последнем натуральное, вторая кнопка меняет знак '+' на '-' и обратно в Wpm. Wr используется в Hex, для определения минимального кол-ва знаков записи; 

1) Кнопки округления: 
Button_round, вызов функции Round (Банковское округление); 
Button_trunc, вызов функции Trunc (Округление до целого); 
Button_simto, вызов функции SimpleRoundTo (Математическое округление): 
Использует Wr и Wpm для определения десятка, до которого округлять. 



Собственный Unit 
0) Uses: 
System.SysUtils (Библиотека с IntToStr, StringReplace...); 
Math (Библиотека с Power...); 

1) Function: 
function IntToBin(Number, Radix: Integer): String; 
function BinToInt(Number: Integer): Integer; 

2) IntToBin
Пока первое входное значение больше нуля, она записывает подряд значения остатка от его целочисленного деления на 2 и приравнивает его к целочисленному делению на 2, дальше сравнивает его длину со вторым входящим значением и, если оно меньше, дописывает ведущие нули. 

3) BinToInt 
Сначала проверяет бинарность числа, заменяя все '0' и '1' на '', если в итоге ничего не остаётся, то оно бинарно, если иначе, выдает в результат -1, бинарное число она проводит по обратному циклу равному длине числа, в котором суммирует степени двоек, соответствующих положению начиная с 0.   



Итог: 
Калькулятор работает в соответствии с заданием, имеет даже больший функционал. Теоретический знания, закреплены практикой. 
